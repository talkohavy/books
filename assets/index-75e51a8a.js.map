{"version":3,"file":"index-75e51a8a.js","sources":["../../node_modules/.pnpm/@tanstack+query-core@4.35.7/node_modules/@tanstack/query-core/build/lib/infiniteQueryObserver.mjs","../../node_modules/.pnpm/@tanstack+react-query@4.35.7_react-dom@18.2.0_react@18.2.0/node_modules/@tanstack/react-query/build/lib/useInfiniteQuery.mjs","../../node_modules/.pnpm/@babel+runtime@7.23.1/node_modules/@babel/runtime/helpers/esm/extends.js","../../node_modules/.pnpm/@babel+runtime@7.23.1/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../../node_modules/.pnpm/@babel+runtime@7.23.1/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../../node_modules/.pnpm/@babel+runtime@7.23.1/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../../node_modules/.pnpm/memoize-one@5.2.1/node_modules/memoize-one/dist/memoize-one.esm.js","../../node_modules/.pnpm/react-window@1.8.9_react-dom@18.2.0_react@18.2.0/node_modules/react-window/dist/index.esm.js","../../src/components/Pagination/constants.js","../../src/components/Pagination/MoveToPageLink.jsx","../../src/components/Pagination/NextPageButton.jsx","../../src/components/Pagination/PreviousPageButton.jsx","../../src/components/Pagination/ThreeDots.jsx","../../src/components/Pagination/Pagination.jsx","../../src/hooks/useEventListener.jsx","../../src/hooks/useWidthHeightResize.jsx","../../src/components/Select.jsx","../../src/pages/BooksPage/BooksListTopPanel.jsx","../../src/pages/BooksPage/constants.js","../../src/pages/BooksPage/useInfiniteBooksData.js","../../src/pages/BooksPage/BooksList.jsx"],"sourcesContent":["import { QueryObserver } from './queryObserver.mjs';\nimport { infiniteQueryBehavior, hasNextPage, hasPreviousPage } from './infiniteQueryBehavior.mjs';\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    const {\n      isFetching,\n      isRefetching\n    } = result;\n    const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward';\n    const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward';\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n  }\n\n}\n\nexport { InfiniteQueryObserver };\n//# sourceMappingURL=infiniteQueryObserver.mjs.map\n","'use client';\nimport { parseQueryArgs, InfiniteQueryObserver } from '@tanstack/query-core';\nimport { useBaseQuery } from './useBaseQuery.mjs';\n\nfunction useInfiniteQuery(arg1, arg2, arg3) {\n  const options = parseQueryArgs(arg1, arg2, arg3);\n  return useBaseQuery(options, InfiniteQueryObserver);\n}\n\nexport { useInfiniteQuery };\n//# sourceMappingURL=useInfiniteQuery.mjs.map\n","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _class;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var _this$props2 = this.props,\n          itemCount = _this$props2.itemCount,\n          layout = _this$props2.layout;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\n\n      var scrollbarSize = 0;\n\n      if (this._outerRef) {\n        var outerRef = this._outerRef;\n\n        if (layout === 'vertical') {\n          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;\n        } else {\n          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;\n        }\n      }\n\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          initialScrollOffset = _this$props3.initialScrollOffset,\n          layout = _this$props3.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props4 = this.props,\n          direction = _this$props4.direction,\n          layout = _this$props4.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props5 = this.props,\n          children = _this$props5.children,\n          className = _this$props5.className,\n          direction = _this$props5.direction,\n          height = _this$props5.height,\n          innerRef = _this$props5.innerRef,\n          innerElementType = _this$props5.innerElementType,\n          innerTagName = _this$props5.innerTagName,\n          itemCount = _this$props5.itemCount,\n          itemData = _this$props5.itemData,\n          _this$props5$itemKey = _this$props5.itemKey,\n          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,\n          layout = _this$props5.layout,\n          outerElementType = _this$props5.outerElementType,\n          outerTagName = _this$props5.outerTagName,\n          style = _this$props5.style,\n          useIsScrolling = _this$props5.useIsScrolling,\n          width = _this$props5.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props6 = this.props,\n          itemCount = _this$props6.itemCount,\n          overscanCount = _this$props6.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar _excluded = [\"style\"],\n    _excluded2 = [\"style\"];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n","const STRATEGY = {\n  // Display format: 1 2 3 4 5 6 7 8\n  SHOW_ALL_PAGES: ({ curPage, pageNumbersArr }) =>\n    pageNumbersArr.map((pageNumber) => ({ isCurrentPage: curPage == pageNumber, pageNumber })),\n\n  // Display format: 1 2 3 4 5 ... 26\n  DISPLAY_FIRST_FIVE_AND_LAST: ({ curPage, numOfPages }) => {\n    const pagesArr = [];\n    // -- display first 5 pages\n    for (let pageNumber = 1; pageNumber <= 5; pageNumber++) {\n      pagesArr.push({ isCurrentPage: curPage == pageNumber, pageNumber });\n    }\n\n    // -- display 3 dots and then the last page\n    pagesArr.push({ isThreeDots: true, pageNumber: -2 }, { isLastPage: true, pageNumber: numOfPages });\n\n    return pagesArr;\n  },\n\n  // Display format: 1 ... 22 23 24 25 26\n  DISPLAY_FIRST_AND_FIVE_LAST: ({ curPage, numOfPages }) => {\n    const pagesArr = [];\n    // -- display first page and then the 3 dots\n    pagesArr.push({ pageNumber: 1 }, { isThreeDots: true, pageNumber: -1 });\n\n    // -- display last 5 pages\n    for (let i = numOfPages - 5; i <= numOfPages; i++) {\n      pagesArr.push({ isCurrentPage: curPage == i, pageNumber: i });\n    }\n\n    return pagesArr;\n  },\n\n  // Display format: 1 ... 3 4 |5| 6 7 ... 9\n  DISPLAY_FIRST_LAST_AND_FIVE_IN_MIDDLE: ({ curPage, numOfPages }) => {\n    const pagesArr = [];\n    // -- display first page and then the 3 dots\n    pagesArr.push({ pageNumber: 1 }, { isThreeDots: true, pageNumber: -1 });\n\n    // -- display middle 5 pages\n    for (let i = curPage - 2; i <= curPage + 2; i++) {\n      pagesArr.push({ isCurrentPage: curPage == i, pageNumber: i });\n    }\n\n    // Step 4: display 3 dots & the last page\n    pagesArr.push({ isThreeDots: true, pageNumber: -2 }, { pageNumber: numOfPages });\n\n    return pagesArr;\n  },\n};\n\n// const STRATEGY_OPTIONS = Object.keys(STRATEGY).reduce((acc, curKey) => ({ ...acc, [curKey]: curKey }), {});\nconst STRATEGY_OPTIONS = {\n  SHOW_ALL_PAGES: 'SHOW_ALL_PAGES',\n  DISPLAY_FIRST_FIVE_AND_LAST: 'DISPLAY_FIRST_FIVE_AND_LAST',\n  DISPLAY_FIRST_AND_FIVE_LAST: 'DISPLAY_FIRST_AND_FIVE_LAST',\n  DISPLAY_FIRST_LAST_AND_FIVE_IN_MIDDLE: 'DISPLAY_FIRST_LAST_AND_FIVE_IN_MIDDLE',\n};\n\nfunction getDisplayType({ numOfPages, curPage }) {\n  let displayType = '';\n  if (numOfPages <= 8) displayType = STRATEGY_OPTIONS.SHOW_ALL_PAGES;\n  else if (curPage <= 4) displayType = STRATEGY_OPTIONS.DISPLAY_FIRST_FIVE_AND_LAST;\n  else if (curPage >= numOfPages - 3) displayType = STRATEGY_OPTIONS.DISPLAY_FIRST_AND_FIVE_LAST;\n  else displayType = STRATEGY_OPTIONS.DISPLAY_FIRST_LAST_AND_FIVE_IN_MIDDLE;\n\n  return displayType;\n}\n\nexport { STRATEGY, STRATEGY_OPTIONS, getDisplayType };\n","import React from 'react';\n\nexport default function MoveToPageLink({ pageNumber, className, onClick }) {\n  return (\n    <div key={pageNumber} onClick={onClick} className={className}>\n      {pageNumber}\n    </div>\n  );\n}\n","import React from 'react';\nimport clsx from 'clsx';\n\nexport default function NextPageButton({ curPage, setCurPage, numOfPages }) {\n  return (\n    <span\n      className={clsx(\n        'flex h-7 w-7 cursor-pointer select-none items-center justify-center rounded-full bg-gray-600 pb-1 text-center text-lg text-white dark:bg-amber-400 dark:text-black',\n        curPage == numOfPages\n          ? 'cursor-default bg-neutral-300 dark:bg-transparent'\n          : 'hover:bg-black active:bg-gray-400 dark:hover:bg-black dark:hover:text-white dark:active:bg-yellow-600'\n      )}\n      onClick={() => curPage < numOfPages && setCurPage(curPage + 1)}\n    >\n      \n    </span>\n  );\n}\n","import React from 'react';\nimport clsx from 'clsx';\n\nexport default function PreviousPageButton({ currentPage, setCurPage }) {\n  return (\n    <span\n      className={clsx(\n        'flex h-7 w-7 cursor-pointer select-none items-center justify-center rounded-full bg-gray-600 pb-1 text-center text-lg text-white',\n        currentPage == 1 ? 'cursor-default bg-neutral-300 dark:bg-transparent' : 'hover:bg-black active:bg-gray-400'\n      )}\n      onClick={() => currentPage > 1 && setCurPage(currentPage - 1)}\n    >\n      \n    </span>\n  );\n}\n","import React from 'react';\n\nexport default function ThreeDots() {\n  return <span className='w-auto'>...</span>;\n}\n","import React, { useMemo } from 'react';\nimport clsx from 'clsx';\nimport { STRATEGY, getDisplayType } from './constants';\nimport MoveToPageLink from './MoveToPageLink';\nimport NextPageButton from './NextPageButton';\nimport PreviousPageButton from './PreviousPageButton';\nimport ThreeDots from './ThreeDots';\n\nexport default function Pagination({ curPage, setCurPage, totalNumOfItems, perPage }) {\n  // all useStates:\n  const numOfPages = useMemo(() => Math.ceil(totalNumOfItems / perPage), [totalNumOfItems, perPage]);\n  const pageNumbersArr = useMemo(() => Array.from(Array(numOfPages).keys()).map((index) => index + 1), [numOfPages]);\n\n  // all useMemos:\n  const currentPage = useMemo(() => parseInt(curPage), [curPage]);\n  const paginationLinks = useMemo(() => {\n    const displayType = getDisplayType({ curPage: currentPage, numOfPages });\n    return STRATEGY[displayType]({ curPage: currentPage, numOfPages, pageNumbersArr });\n  }, [numOfPages, currentPage, pageNumbersArr]);\n\n  return (\n    <div className='flex h-10 w-full max-w-xl items-center justify-around dark:text-white'>\n      {numOfPages ? (\n        <>\n          <PreviousPageButton currentPage={currentPage} setCurPage={setCurPage} />\n\n          {paginationLinks.map(({ isThreeDots, isCurrentPage, pageNumber }) =>\n            isThreeDots ? (\n              <ThreeDots key={pageNumber} />\n            ) : (\n              <MoveToPageLink\n                key={pageNumber}\n                pageNumber={pageNumber}\n                onClick={() => !isCurrentPage && setCurPage(pageNumber)}\n                className={clsx(\n                  'w-auto rounded-md px-2 py-1 text-lg no-underline',\n                  isCurrentPage\n                    ? 'cursor-default bg-red-500 text-white'\n                    : 'cursor-pointer hover:bg-slate-200 dark:hover:bg-red-800'\n                )}\n              />\n            )\n          )}\n\n          <NextPageButton curPage={currentPage} setCurPage={setCurPage} numOfPages={numOfPages} />\n        </>\n      ) : null}\n    </div>\n  );\n}\n","import React, { useEffect, useRef } from 'react';\n\n/**\n * @param {{\n *    eventType: string,\n *    fnToRun: (props: any) => void,\n *    dependencies?: Array,\n *    element?: any\n *    shouldNotRender?: boolean\n * }} props\n */\nexport default function useEventListener({ eventType, fnToRun, dependencies = [], element = window, shouldNotRender }) {\n  const callbackRef = useRef(fnToRun);\n\n  useEffect(() => ((callbackRef.current = fnToRun), undefined), [fnToRun]);\n\n  useEffect(() => {\n    if (shouldNotRender) return;\n\n    element.addEventListener(eventType, callbackRef.current);\n\n    callbackRef.current();\n\n    return () => element.removeEventListener(eventType, callbackRef.current);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n}\n","import { useCallback, useState } from 'react';\nimport { wrapInDebounce } from '../utils/wrapInDebounce';\nimport useEventListener from './useEventListener';\n\n/**\n * @param {{\n *    wrapperRef: any,\n *    fnToRun?: (value: any) => void,\n *    shouldNotRender?: boolean,\n *    ms?: number,\n * }} props\n */\nexport function useWidthHeightResize({ wrapperRef, fnToRun, ms = 300, shouldNotRender }) {\n  const [size, setSize] = useState({ width: 0, height: 0 });\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const memoizedCallback = useCallback(\n    wrapInDebounce(() => {\n      const { width, height } = wrapperRef.current.getBoundingClientRect();\n      const newSize = { width, height };\n      setSize(newSize);\n      fnToRun?.(newSize);\n    }, ms),\n    []\n  );\n\n  useEventListener({\n    eventType: 'resize',\n    fnToRun: memoizedCallback,\n    dependencies: [shouldNotRender],\n    shouldNotRender,\n  });\n\n  return size;\n}\n","import React from 'react';\nimport clsx from 'clsx';\n\nexport default function Select({ value, setValue, options, placeholder = '', className = undefined }) {\n  return (\n    <select\n      value={value}\n      onChange={setValue}\n      className={clsx('h-8 cursor-pointer rounded-md border hover:border-blue-400 focus:border-blue-600', className)}\n      placeholder={placeholder}\n    >\n      {options.map(({ key, value, label }) => (\n        <option key={key ?? value} value={value}>\n          {label}\n        </option>\n      ))}\n    </select>\n  );\n}\n","import Button from '../../components/Button';\nimport Input from '../../components/Input';\nimport Select from '../../components/Select';\n\nexport default function BooksListTopPanel({\n  searchText,\n  setSearchText,\n  onSearchClick,\n  viewType,\n  setViewType,\n  viewTypeOptions,\n}) {\n  return (\n    <div className='flex items-center justify-start gap-3'>\n      <Select value={viewType} setValue={setViewType} options={viewTypeOptions} className='!h-10 w-36 border-black' />\n\n      <Input value={searchText} setValue={setSearchText} className='!w-60 max-w-full' />\n\n      <Button\n        isDisabled={!searchText}\n        onClick={onSearchClick}\n        className='h-10 w-20 rounded-xl border border-black bg-blue-600 p-1 text-white hover:rounded-2xl hover:bg-blue-500 focus:bg-blue-700'\n      >\n        Search\n      </Button>\n    </div>\n  );\n}\n","const resultsPerPageObj = {\n  10: { value: 10, label: 'Show 10' },\n  20: { value: 20, label: 'Show 20' },\n  50: { value: 50, label: 'Show 50' },\n  null: { value: 0, label: 'Show all' },\n};\nconst resultsPerPageOptions = Object.keys(resultsPerPageObj).map((key) => resultsPerPageObj[key]);\n\nconst GUTTER_SIZE = 20;\nconst ITEMS_PER_PAGE = 24;\nconst BOTTOM_GAP_TO_LOAD_MORE = 800;\nconst RIGHT_GAP_TO_SCROLLBAR = 20;\n\nconst VIEW_TYPES = {\n  PaginationView: { value: 'PaginationView', label: 'Pagination' },\n  InfiniteScrollView: { value: 'InfiniteScrollView', label: 'Infinite Scroll' },\n};\n\nconst viewTypeOptions = Object.values(VIEW_TYPES);\n\nfunction getGridPropsFromContainerWidth(width) {\n  if (width > 1280) return { cardsPerRow: 4, columnWidth: 300, rowHeight: 300 };\n  if (width > 930) return { cardsPerRow: 3, columnWidth: 300, rowHeight: 300 };\n  if (width > 640) return { cardsPerRow: 2, columnWidth: 300, rowHeight: 300 };\n  // if (width > 480) return { cardsPerRow: 1, columnWidth: 500 };\n  return { cardsPerRow: 1, columnWidth: 420, rowHeight: 420 };\n}\n\nexport {\n  BOTTOM_GAP_TO_LOAD_MORE,\n  GUTTER_SIZE,\n  ITEMS_PER_PAGE,\n  RIGHT_GAP_TO_SCROLLBAR,\n  VIEW_TYPES,\n  getGridPropsFromContainerWidth,\n  resultsPerPageObj,\n  resultsPerPageOptions,\n  viewTypeOptions,\n};\n","import axios from 'axios';\nimport { useInfiniteQuery } from '@tanstack/react-query';\nimport { ITEMS_PER_PAGE } from './constants';\n\nconst QID_BOOKS_DATA_INFINITE = 'QID_BOOKS_DATA_INFINITE';\n\n/**\n * @param {{\n *    queryKey: any;\n *    pageParam: any;\n *    signal?: any;\n *    meta: any;\n * }} props\n */\nasync function fetchBooks({ queryKey }) {\n  const pageParam = Math.max(queryKey[3] - 1, 0);\n  const axiosOptions = {\n    params: { startIndex: pageParam * queryKey[2], q: queryKey[1] || 'search+terms', maxResults: queryKey[2] },\n  };\n  return axios.get('https://www.googleapis.com/books/v1/volumes', axiosOptions);\n}\n\n/**\n * @param {{\n *    itemsPerPage?: number,\n *    searchText?: string,\n *    curViewType?: string,\n *    curPage?: number,\n * }} props\n */\nexport function useInfiniteBooksData({ itemsPerPage, searchText, curPage, curViewType } = {}) {\n  !itemsPerPage && (itemsPerPage = ITEMS_PER_PAGE); // <--- NOTE! in pagination mode, this should always be defined. In infinite scroll mode, this should NOT be defined! (either undefined, null, or 0).\n\n  return useInfiniteQuery({\n    queryKey: [QID_BOOKS_DATA_INFINITE, searchText, itemsPerPage, curPage, curViewType],\n    queryFn: fetchBooks,\n    cacheTime: 300000, // <--- default value is 5 minutes = 5 * 60 * 1000 = 300000!\n    // staleTime: 30000, // <--- default value is 0. Every re-visit would trigger a background refetch.\n    refetchOnWindowFocus: false,\n    keepPreviousData: true, // <--- Useful for both pagination & infinite scroll! Defaults to false. Set this to true to keep the previous data when fetching based on a new query key.\n    select: ({ pageParams, pages }) => ({ pageParams, pages: pages.map((item) => item.data) }), // <--- do data-transformation on the response!\n    getNextPageParam: (_lastPage, pages) => pages.length + 1,\n  });\n}\n","import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { FixedSizeGrid as Grid } from 'react-window';\nimport Pagination from '../../components/Pagination';\nimport { checkIsFavored } from '../../database';\nimport { useLocalStorage } from '../../hooks/useLocalStorage';\nimport { useWidthHeightResize } from '../../hooks/useWidthHeightResize';\nimport { LSKEY_VIEW_TYPE } from '../../utils/appConstants';\nimport BookCard from './BookCard';\nimport BooksTableTopPanel from './BooksListTopPanel';\nimport {\n  BOTTOM_GAP_TO_LOAD_MORE,\n  GUTTER_SIZE,\n  ITEMS_PER_PAGE,\n  RIGHT_GAP_TO_SCROLLBAR,\n  VIEW_TYPES,\n  getGridPropsFromContainerWidth,\n  viewTypeOptions,\n} from './constants';\nimport { useInfiniteBooksData } from './useInfiniteBooksData';\n\nexport default function BooksList() {\n  // all useRefs:\n  const wrapperRef = useRef(null);\n\n  // all useLocalStorages:\n  const [viewType, setViewType] = useLocalStorage(LSKEY_VIEW_TYPE);\n\n  // all useStates:\n  const [curPage, setCurPage] = useState(1);\n  const [gridProps, setGridProps] = useState(() => getGridPropsFromContainerWidth(window.innerWidth));\n  const [searchTextLocally, setSearchTextLocally] = useState('');\n  const [searchTextFetch, setSearchTextFetch] = useState('');\n\n  const { data, isLoading, isFetching, fetchNextPage } = useInfiniteBooksData({\n    itemsPerPage: ITEMS_PER_PAGE,\n    searchText: searchTextFetch,\n    curViewType: viewType,\n    curPage,\n  });\n\n  const flatData = useMemo(() => data?.pages?.flatMap((page) => page.items).filter(Boolean) ?? [], [data]);\n  const totalItemsOverallCount = !data ? 0 : data.pages[0].totalItems;\n  const totalItemsLoadedCount = flatData.length;\n  const ROWS_PER_PAGE = ITEMS_PER_PAGE / gridProps.cardsPerRow;\n  const rowsCount = Math.ceil(totalItemsLoadedCount / gridProps.cardsPerRow);\n\n  // all useCallbacks:\n  const onSearchClick = useCallback(() => {\n    setCurPage(1);\n    setSearchTextFetch(searchTextLocally);\n  }, [searchTextLocally]);\n  const fetchMoreOnBottomReached = useCallback(\n    (containerRefElement) => {\n      if (containerRefElement) {\n        const veryLongContainer = containerRefElement.firstElementChild.firstElementChild;\n        const containerHeight = veryLongContainer.style.height;\n        const gapOfLastChildFromTop = veryLongContainer.lastElementChild?.style?.top;\n        if (!gapOfLastChildFromTop) return;\n        const gapFromBottom = parseFloat(containerHeight) - parseFloat(gapOfLastChildFromTop);\n        if (gapFromBottom < BOTTOM_GAP_TO_LOAD_MORE && !isFetching && totalItemsLoadedCount < totalItemsOverallCount) {\n          fetchNextPage();\n        }\n      }\n    },\n    [fetchNextPage, isFetching, totalItemsLoadedCount, totalItemsOverallCount]\n  );\n\n  const { height } = useWidthHeightResize({\n    wrapperRef,\n    shouldNotRender: !data,\n    fnToRun: ({ width: containerWidth }) => {\n      setGridProps(getGridPropsFromContainerWidth(containerWidth));\n    },\n    ms: 0,\n  });\n\n  // all useEffects:\n  useEffect(() => {\n    if (isLoading) return;\n\n    /// wrapperRef.current.firstElementChild.className = 'no-scrollbar'; // <--- attach to the gridRealRef the 'no-scrollbar' class name\n  }, [isLoading]);\n\n  useEffect(() => {\n    fetchMoreOnBottomReached(wrapperRef.current);\n  }, [fetchMoreOnBottomReached]);\n\n  if (isLoading) return <div>loading...</div>;\n\n  return (\n    <div className='flex h-full w-full flex-col items-center justify-start gap-6 p-10'>\n      <BooksTableTopPanel\n        searchText={searchTextLocally}\n        setSearchText={setSearchTextLocally}\n        onSearchClick={onSearchClick}\n        viewType={viewType}\n        setViewType={(e) => setViewType(e.target.value)}\n        viewTypeOptions={viewTypeOptions}\n      />\n\n      <div className='flex h-[calc(100%-12rem)] w-full flex-1 flex-col items-center justify-center' ref={wrapperRef}>\n        <Grid\n          width={gridProps.columnWidth * gridProps.cardsPerRow + RIGHT_GAP_TO_SCROLLBAR}\n          height={height}\n          columnWidth={gridProps.columnWidth}\n          columnCount={gridProps.cardsPerRow}\n          rowCount={rowsCount}\n          rowHeight={gridProps.rowHeight}\n          onScroll={() =>\n            viewType === VIEW_TYPES.InfiniteScrollView.value && fetchMoreOnBottomReached(wrapperRef.current)\n          }\n        >\n          {({ columnIndex, rowIndex, style }) => {\n            const pageIndex = Math.floor(rowIndex / ROWS_PER_PAGE);\n            const itemIndex = (rowIndex * gridProps.cardsPerRow + columnIndex) % ITEMS_PER_PAGE;\n            const bookData = data?.pages[pageIndex].items[itemIndex];\n            const { volumeInfo, id } = bookData ?? {};\n            const { title, pageCount, publishedDate, imageLinks } = volumeInfo ?? {};\n\n            return (\n              bookData && (\n                <div\n                  style={{\n                    ...style,\n                    // @ts-ignore\n                    left: style.left,\n                    // @ts-ignore\n                    top: style.top,\n                    // @ts-ignore\n                    width: style.width - GUTTER_SIZE,\n                    // @ts-ignore\n                    height: style.height - GUTTER_SIZE,\n                  }}\n                >\n                  <BookCard\n                    id={id}\n                    key={itemIndex}\n                    title={title}\n                    pageCount={pageCount}\n                    publishedDate={publishedDate}\n                    imageLinks={imageLinks}\n                    isFavored={checkIsFavored(id)}\n                  />\n                </div>\n              )\n            );\n          }}\n        </Grid>\n      </div>\n\n      {viewType === VIEW_TYPES.PaginationView.value && (\n        <Pagination\n          perPage={ITEMS_PER_PAGE}\n          curPage={curPage}\n          setCurPage={setCurPage}\n          totalNumOfItems={totalItemsOverallCount}\n        />\n      )}\n    </div>\n  );\n}\n"],"names":["InfiniteQueryObserver","QueryObserver","client","options","notifyOptions","infiniteQueryBehavior","pageParam","query","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","_state$data","_state$data2","state","result","isFetching","isRefetching","isFetchingNextPage","isFetchingPreviousPage","hasNextPage","hasPreviousPage","useInfiniteQuery","arg1","arg2","arg3","parseQueryArgs","useBaseQuery","_extends","target","i","source","key","_assertThisInitialized","self","_setPrototypeOf","o","p","_inheritsLoose","subClass","superClass","setPrototypeOf","safeIsNaN","value","isEqual","first","second","areInputsEqual","newInputs","lastInputs","memoizeOne","resultFn","lastThis","lastArgs","lastResult","calledOnce","memoized","newArgs","_i","hasNativePerformanceNow","now","cancelTimeout","timeoutID","requestTimeout","callback","delay","start","tick","size","getScrollbarSize","recalculate","div","style","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","innerDiv","innerStyle","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","_ref","columnIndex","rowIndex","createGridComponent","_ref2","_class","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","Grid","props","_this","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","scrollLeft","scrollTop","horizontalScrollDirection","verticalScrollDirection","scrollUpdateWasRequested","_this$props","columnWidth","direction","rowHeight","itemStyleCache","_offset","isRtl","_","__","___","event","_event$currentTarget","clientHeight","clientWidth","scrollHeight","scrollWidth","prevState","calculatedScrollLeft","calculatedScrollTop","ref","outerRef","nextProps","validateSharedProps","_proto","_ref3","_ref4","_ref4$align","align","_this$props2","columnCount","height","rowCount","width","_this$state","scrollbarSize","estimatedTotalHeight","estimatedTotalWidth","horizontalScrollbarSize","verticalScrollbarSize","_this$props3","initialScrollLeft","initialScrollTop","_this$state2","_this$props4","children","className","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","isScrolling","_this$_getHorizontalR","columnStartIndex","columnStopIndex","_this$_getVerticalRan","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","createElement","_this$props5","onItemsRendered","onScroll","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnCount","overscanColumnsCount","overscanCount","_this$state4","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","_this$props7","overscanRowCount","overscanRowsCount","_this$state5","PureComponent","_ref5","_ref6","FixedSizeGrid","index","_ref7","instanceProps","lastColumnOffset","maxOffset","minOffset","middleOffset","_ref8","lastRowOffset","_ref9","_ref10","left","numVisibleColumns","_ref11","_ref12","top","numVisibleRows","_ref13","STRATEGY","curPage","pageNumbersArr","pageNumber","numOfPages","pagesArr","STRATEGY_OPTIONS","getDisplayType","displayType","MoveToPageLink","onClick","jsx","NextPageButton","setCurPage","clsx","PreviousPageButton","currentPage","ThreeDots","Pagination","totalNumOfItems","perPage","useMemo","paginationLinks","jsxs","Fragment","isThreeDots","isCurrentPage","useEventListener","eventType","fnToRun","dependencies","element","shouldNotRender","callbackRef","useRef","useEffect","useWidthHeightResize","wrapperRef","ms","setSize","useState","memoizedCallback","useCallback","wrapInDebounce","newSize","Select","setValue","placeholder","label","BooksListTopPanel","searchText","setSearchText","onSearchClick","viewType","setViewType","viewTypeOptions","Input","Button","resultsPerPageObj","GUTTER_SIZE","ITEMS_PER_PAGE","BOTTOM_GAP_TO_LOAD_MORE","RIGHT_GAP_TO_SCROLLBAR","VIEW_TYPES","getGridPropsFromContainerWidth","QID_BOOKS_DATA_INFINITE","fetchBooks","queryKey","axiosOptions","axios","useInfiniteBooksData","itemsPerPage","curViewType","pageParams","pages","item","_lastPage","BooksList","useLocalStorage","LSKEY_VIEW_TYPE","gridProps","setGridProps","searchTextLocally","setSearchTextLocally","searchTextFetch","setSearchTextFetch","data","isLoading","fetchNextPage","flatData","_a","page","totalItemsOverallCount","totalItemsLoadedCount","ROWS_PER_PAGE","rowsCount","fetchMoreOnBottomReached","containerRefElement","veryLongContainer","containerHeight","gapOfLastChildFromTop","_b","containerWidth","BooksTableTopPanel","e","pageIndex","itemIndex","bookData","volumeInfo","id","title","pageCount","publishedDate","imageLinks","BookCard","checkIsFavored"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}